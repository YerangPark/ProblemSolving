# ì•Œê³ ë¦¬ì¦˜
ìƒì„±ì¼: Jan 13, 2021 12:40 AM
íƒœê·¸: #ê³µë¶€/algorithm , #ê³µë¶€/C++

[ì•ˆê²½ì¡ì´ê°œë°œì : ë„¤ì´ë²„ ë¸”ë¡œê·¸](https://blog.naver.com/ndb796/221226794899)
- - - -
#### <details><summary>ğŸª„ ëª©ì°¨</summary>
<p>
	
1. ì„ íƒ ì •ë ¬
2. ë²„ë¸” ì •ë ¬
3. ì‚½ì… ì •ë ¬
4. í€µ ì •ë ¬
5. ë³‘í•© ì •ë ¬
6. C++ STL sort(), í, ìŠ¤íƒ
7. í™ ì •ë ¬
8. ê³„ìˆ˜ ì •ë ¬
9. ì‹¬í™” ì •ë ¬ ë¬¸ì œ í’€ì´
10. ìŠ¤íƒ
11. í
12. ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)
13. ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)
14. Union-Find(í•©ì§‘í•© ì°¾ê¸°)
15. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal Algorithm)
16. ì´ì§„ íŠ¸ë¦¬ì˜ êµ¬í˜„ ë° ìˆœíšŒ(Traversal)
17. ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°(Dynamic Programming)
18. ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´
19. í”Œë¡œì´ë“œ ì™€ìƒ¬(Floyd Warshall) ì•Œê³ ë¦¬ì¦˜
20. ìœ„ìƒ ì •ë ¬(Topology Sort)
21. ê°•í•œ ê²°í•© ìš”ì†Œ
22. ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš°
23. ìœ„ìƒ ì •ë ¬ ê¸°ì´ˆ ë¬¸ì œí’€ì´
24. ì´ë¶„ ë§¤ì¹­(Pipartite Matching)
25. KMP(Knuth-Morris-Pratt) ì•Œê³ ë¦¬ì¦˜
26. ë¼ë¹ˆ ì¹´í”„ ì•Œê³ ë¦¬ì¦˜
27. ì´ë¶„ ë§¤ì¹­ ê¸°ì´ˆ ë¬¸ì œí’€ì´
28. ê°•í•œ ê²°í•© ìš”ì†Œ ê¸°ì´ˆ ë¬¸ì œí’€ì´
29. ê·¸ë¦¬ë””(Greedy) ì•Œê³ ë¦¬ì¦˜
30. êµ¬ê¸€ ì½”ë“œ ì¼ 2018ì—ì„œ ì‚´í´ë³´ëŠ” ê¸°ì´ˆ ê·¸ë¦¬ë”” ë¬¸ì œ
31. ì—ë¼í† ìŠ¤í…Œë„¤ìŠ¤ì˜ ì²´ ê¸°ì´ˆ ë¬¸ì œí’€ì´
32. ë¶„í•  ì •ë³µ ê¸°ì´ˆ ë¬¸ì œí’€ì´
33. ì´ë¶„ íƒìƒ‰(Binary Search)
34. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬
35. ìµœì†Œ ê³µí†µ ì¡°ìƒ
36. ê¹ƒí—ˆë¸Œë¡œ ì•Œê³ ë¦¬ì¦˜ ì •ë‹µ ì†ŒìŠ¤ì½”ë“œ ê´€ë¦¬í•˜ê¸°
37. ì¸ë±ìŠ¤ íŠ¸ë¦¬
38. ë¹„íŠ¸ ë§ˆìŠ¤í¬

</details>
</p>
- - - -
[[ì•Œê³ ë¦¬ì¦˜ í•œ ë¬¸ì¥ ì •ë¦¬]]
- - - -
## ì„ íƒ ì •ë ¬ O(n^2)
- ë°°ì—´ 0í•­ë¶€í„° ì°¨ë¡€ë¡œ ìˆœíšŒí•˜ë©´ì„œ ìš°ì¸¡ í•­ ì¤‘ ìµœì†Ÿê°’ì„ ì°¾ì•„ì„œ íƒìƒ‰ ìœ„ì¹˜(ê¸°ì¤€ ìœ„ì¹˜)ì™€ ë³€ê²½
* ë°°ì—´ì˜ ìë¦¬ë¥¼ ì°¨ë¡€ëŒ€ë¡œ íƒìƒ‰í•˜ë©° ìš°ì¸¡ì˜ ìµœì†Ÿê°’ì„ ì°¾ì•„ì„œ íƒìƒ‰ ìœ„ì¹˜ì™€ ë³€ê²½.
```cpp
//review
int main() {
    int arr[4]={5,4,2,3};
    int i,j,len=sizeof(arr)/sizeof(int),min=1000,minIndex;

    for(i=0;i<len-1;i++){
        minIndex=i;
        min=arr[i];
        for(j=i+1;j<len;j++){
            if(min>arr[j]){
                minIndex=j;
                min=arr[j];
            }
        }
        int tmp=arr[minIndex];
        arr[minIndex]=arr[i];
        arr[i]=tmp;
    }
    
    for(i=0;i<len;i++){
        printf("%d ",arr[i]);
    }
    
    return 0;
}
```

```cpp
int i=0,j=0,min=0,index=0,temp=0;
int array[10]={1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
for(i=0;i<10;i++){
    min=9999;
    for(j=i;j<10;j++){
        if(min>array[j]){
            min=array[j];
            index=j;
        }
    }
    temp=array[i];
    array[i]=array[index];
    array[index]=temp;
}
for(i=0;i<10;i++){
    printf("%d ", array[i]);
}
return 0;
```

- - - -
## ë²„ë¸” ì •ë ¬ O(n^# 2)

* 2í•­ì„ ë¹„êµí•˜ì—¬ í¬ë©´ ìš°ì¸¡ìœ¼ë¡œ ìë¦¬ ì´ë™ì„ ë°˜ë³µ.
* ìµœëŒ“ê°’ì´ ì°¨ë¡€ëŒ€ë¡œ ìš°ì¸¡ì— ìŒ“ì´ëŠ” í˜•ì‹!
```cpp //review
int main() {
    int arr[4]={5,4,2,3};
    int i,j,len=sizeof(arr)/sizeof(int);

    for(i=0;i<len;i++){
        for(j=0;j+1<len-i;j++){
            if(arr[j]>arr[j+1]){
                int tmp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tmp;
            }
        }
    }
    for(i=0;i<len;i++){
        printf("%d ",arr[i]);
    }
    return 0;
}
```

```cpp
    int i=0,j=0,temp=0;
    int array[10]={1,10,5,8,7,6,4,3,2,9};
    for(i=0;i=10;i++){
        for(j=0;j<9-i;j++){
            if(array[j]>array[j+1]){
                temp=array[j];
                array[j]=array[j+1];
                array[j+1]=temp;
            }
        }
    }
```

- - - -
## ì‚½ì… ì •ë ¬ O(n^2)

* ë°ì´í„°ê°€ ì´ë¯¸ ê±°ì˜ ì •ë ¬ëœ ìƒíƒœì´ë©´ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ë³´ë‹¤ ë¹ ë¦„.
* ë²”ìœ„ë¥¼ ì ì°¨ ë„“í˜€ê°€ë©° ì™¼ìª½ìœ¼ë¡œ ìµœì†Ÿê°’ì„ ëª¨ëŠ” í˜•íƒœ. (1ì”© ì¦ê°€í•˜ëŠ” `key(i)`ì˜ ì¢Œì¸¡ì— ìˆëŠ” í•­ì„ ì •ë ¬)

```cpp
    int i=0,j=0,temp=0;
    int array[10]={1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for(i=0;i<10;i++){
        j=i;
        while(j>=0 && array[j]>array[j+1]){
            temp=array[j];
            array[j]=array[j+1];
            array[j+1]=temp;
            j--;
        }
    }
    for(i=0;i<10;i++){
        printf("%d ",array[i]);
    }
    return 0;
```

- - - -
## í€µ ì •ë ¬ O(n*log n)
[ì•Œê³ ë¦¬ì¦˜ í€µ ì •ë ¬(quick sort)ì´ë€ - Heeeâ€™s Development Blog](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html)
- **ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜** ì¤‘ í•˜ë‚˜.
(ë¶„í•  ì •ë³µ(divide and conquer): ë¬¸ì œë¥¼ ì‘ì€ 2ê°œì˜ ë¬¸ì œë¡œ ë¶„ë¦¬í•˜ê³ , ê°ê°ì„ í•´ê²°í•œ ë‹¤ìŒ ê²°ê³¼ë¥¼ ëª¨ì•„ì„œ ì›ë˜ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•. ëŒ€ê°œ ìˆœí™˜ í˜¸ì¶œì„ ì´ìš©í•˜ì—¬ êµ¬í˜„)
* íŠ¹ì •í•œ ê°’(í”¼ë²—, ë³´í†µ ì²« ë²ˆì§¸ ì›ì†Œ)ì„ ê¸°ì¤€ìœ¼ë¡œ í° ìˆ«ìì™€ ì‘ì€ ìˆ«ìë¥¼ ì„œë¡œêµí™˜í•œ ë’¤ì— ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ”.
* C++ì—ì„œ ì œê³µí•´ì£¼ëŠ” `<algorithm>` ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `sort()`í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ë©´ í¸í•¨.
(ìµœì•…ì˜ ê²½ìš°ì—ì„œë„ O(n*logn)ì„ ë³´ì¥.)

```cpp
int number=10;
int data[10]={5,3,10,8,1,4,9,2,6,7};
    
//í€µì •ë ¬ì€ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë ¬í•˜ê¸°ì— ê° ë¦¬ìŠ¤íŠ¸ë“¤ì˜ ì‹œì‘ ì¸ë±ìŠ¤ì™€ ë ì¸ë±ìŠ¤ê°€ ì‹ë³„ë˜ì–´ì•¼ í•˜ë¯€ë¡œ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ.
void quickSort(int *data, int start, int end){
    int temp=0;
    //ì›ì†Œê°€ 1ê°œì¸ ê²½ìš°
    if(start>=end){
        return;
    }
    int key=start;  //keyëŠ” ì²« ë²ˆì§¸ ì›ì†Œ.
    int i=start+1;  //ìˆœë°©í–¥ìœ¼ë¡œ keyë³´ë‹¤ í° ê°’ ì°¾ê¸°.
    int j=end;      //ì—­ë°©í–¥ìœ¼ë¡œ keyë³´ë‹¤ ì‘ì€ ê°’ ì°¾ê¸°.
    
    while(i<=j){    //íƒìƒ‰í•˜ë‹¤ê°€ iì™€ jê°€ ì—‡ê°ˆë¦´ ë•Œ ê¹Œì§€ ë°˜ë³µ.
        //ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë³€ê²½í•˜ê³  ì‹¶ì„ ë•ŒëŠ” ì•„ë˜ ì™€ì¼ë¬¸ì˜ ë¶€ë“±í˜¸ë¥¼ ë°˜ëŒ€ë¡œ ë°”ê¿”ì£¼ë©´ ë¨.
        
        //í‚¤ ê°’ë³´ë‹¤ í° ê°’ì„ ë§Œë‚  ë•Œê¹Œì§€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™.
        while(data[i]<=data[key]){
            i++;
        }
        //í‚¤ ê°’ë³´ë‹¤ ì‘ì€ ê°’ì„ ë§Œë‚  ë•Œê¹Œì§€ ì™¼ìª½ìœ¼ë¡œ ì´ë™.(ë‹¨ ë²”ìœ„ ì—‡ë‚˜ê° ë°©ì§€ë¥¼ ìœ„í•´ ì¡°ê±´ ì¶”ê°€)
        while(data[j]>=data[key] && j>start){
            j--;
        }
        
        //ì—‡ê°ˆë¦° ìƒíƒœì´ë©´ jì™€ í‚¤ ê°’ êµì²´.
        if(i>j){
            temp=data[j];
            data[j]=data[key];
            data[key]=temp;
        }else{ //ì—‡ê°ˆë¦¬ì§€ ì•Šì•˜ìœ¼ë©´ ì°¾ì€ iì™€ j êµì²´.
            temp=data[j];
            data[j]=data[i];
            data[i]=temp;
        }
    }
    quickSort(data,start,j-1); //ì™¼ìª½ íŒŒí‹°ì…˜
    quickSort(data, j+1, end); //ì˜¤ë¥¸ìª½ íŒŒí‹°ì…˜
}
```

- - - -
## ë³‘í•© ì •ë ¬ O(n*logn)
ë™ë¹ˆë‚˜ ì„ ìƒë‹˜ì´ ì ê¹ ê±´ë„ˆë›´ë‹¤ê³  í•˜ì…¨ë‹¤.

- - - -
### STL ê´€ë ¨ ë§í¬
[[C++ STL ê°œë… ì •ë¦¬]]
STLì •ë¦¬ëŠ” í•˜ë‹¨ ë§í¬ ì°¸ê³ !
* [ë‚´ì—­ ì •ë¦¬](https://velog.io/@choiiis/C-STL)
* [ìì£¼ì“°ì´ëŠ” ê²ƒ ì •ë¦¬](https://eehoeskrap.tistory.com/246) 
* [ì‚¬ìš©ë²• ì •ë¦¬](https://baactree.tistory.com/29)
* [ê¼¼ê¼¼ ì •ë¦¬(ì–´ë””ì— ë­˜ ì¨ì•¼í• ê¹Œ?)](https://code-algalon.tistory.com/188)
- - - -
## C++ STL sort()
- í—¤ë”: `#include <algorithm>`
- `sort(ì‹œì‘ì£¼ì†Œ, ëì£¼ì†Œ);`
- ê¸°ë³¸ì ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
- ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬í•˜ë ¤ë©´ ì‚¬ìš©ì ì •ì˜í•¨ìˆ˜(bool compare()) ë§Œë“¤ì–´ì„œ  êµ¬í˜„
-> í˜¹ì€,  ì„¸ë²ˆì§¸ ì¸ìì— `greater<>()` ì…ë ¥í•´ë„ ë¨!(ì„ì‹œ ê°ì²´)

### ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ ì˜ˆì‹œ

```cpp
int a[10]={9,3,5,4,1,10,8,6,7,2};
sort(a, a+10); //aë°°ì—´ì˜ 0ë²ˆì§¸ ì¸ë±ìŠ¤ë¶€í„° 9ë²ˆ ì¸ë±ìŠ¤ê¹Œì§€ ì •ë ¬
```

### ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ ì˜ˆì‹œ

* í•¨ìˆ˜ ì´ìš© ì •ë ¬, ì™¼ìª½ì´ ë” í° ìˆ˜ê°€ ì˜¤ë„ë¡ ì •ë ¬.

```cpp
bool compare(int a, int b){
return a>b;
}
int a[10]={9,3,5,4,1,10,8,6,7,2};
sort(a, a+10, compare);
```

> ì‹¤ë¬´ì—ì„œëŠ” í´ë˜ìŠ¤ í˜•íƒœë¥¼ ì´ìš©í•œë‹¤.  
> í•˜ì§€ë§Œ ì½”í…Œì—ì„œëŠ” í´ë˜ìŠ¤ë¥¼ ì´ìš©í•˜ë©´ ë¹„íš¨ìœ¨ì ì´ë¼ì„œ `pair` ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•¨.  

## pair
* `pair`ëŠ” `iostream`, `vector`, `algorithm` ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬í•¨í•´ì•¼ í•¨.
* ë²¡í„° STLì€ ë§ˆì¹˜ ë°°ì—´ê³¼ ê°™ì´ ì‘ë™í•˜ëŠ”ë° ì›ì†Œë¥¼ ì„ íƒì ìœ¼ë¡œ ì‚½ì…, ì‚­ì œí•  ìˆ˜ ìˆìŒ! ë°°ì—´ì„ ë³´ë‹¤ ì‚¬ìš©í•˜ê¸° ì‰½ê²Œ ê°œí¸í•œ ìë£Œêµ¬ì¡°ë¼ê³  í•  ìˆ˜ ìˆë‹¤. 
```cpp
int main(){
    vector<pair<int, string>> v;
    v. push_back(pair<int, string>(90, "ë°•ì˜ˆë‘"));
    v. push_back(pair<int, string>(100, "ë°•ì˜ˆë¡±"));
    v. push_back(pair<int, string>(99, "ë°•ì˜ˆë˜¥"));
    
    sort(v.begin(), v.end());
    for(int i=0;i<v.size();i++){
        cout<<v[i].second<<' ';
    }
    return 0;
}
```

ì˜ˆì œ
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

//ì„±ì ì— ë”°ë¼ ì •ë ¬í•œ ë’¤ ì„±ì ì´ ê°™ìœ¼ë©´ ë‚˜ì´ê°€ ì–´ë¦° ì‚¬ëŒì´ ë¨¼ì € ì¶œë ¥ë˜ê²Œ ë§Œë“¤ì–´ë¼.
bool compare(pair<string, pair<int, int>> a,
             pair<string, pair<int, int>> b){
    //ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ì˜ ì ìˆ˜ê°€ ê°™ìœ¼ë©´
    if(a.second.first == b.second.first){
        //ë‚˜ì´ê°€ ì–´ë¦° ì‚¬ëŒ(ëŠ¦ê²Œ íƒœì–´ë‚œ ì‚¬ëŒ)ìˆœìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
        return a.second.second>b.second.second;
    } else {
        //ì ìˆ˜ê°€ ë‹¤ë¥´ë©´ just ì ìˆ˜ ìˆœìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬(ì™¼ìª½ì— í° ê²ƒì´ ì˜¤ë„ë¡)
        return a.second.first > b.second.first;
    }
}

int main() {
    vector<pair<string,pair<int, int>>> v;
    v.push_back(pair<string,pair<int, int>>("ë°•ì˜ˆë‘",make_pair(90,19980407)));
    v.push_back(pair<string,pair<int, int>>("ë‚˜ë™ë¹ˆ",make_pair(90,19980304)));
    v.push_back(pair<string,pair<int, int>>("ì´íƒœì¼",make_pair(87,19660216)));
    v.push_back(pair<string,pair<int, int>>("ê¹€ìƒìš±",make_pair(80,19771223)));
    v.push_back(pair<string,pair<int, int>>("ê°•ì¢…êµ¬",make_pair(82,19550712)));
    
    sort(v.begin(), v.end(), compare);
    
    for(int i=0;i<v.size();i++){
        cout<<v[i].first<<' ';
    }
    return 0;
}
```

- - - -
## STL ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ë²• (í, ìŠ¤íƒ)

### í

```cpp
#include <queue>
int main(void){
    queue<int> q;
    q.push(1);
    q.push(2);
    q.pop();
    while(!q.empty()){
        cout<<q.front()<<' ';
        q.pop();
    }
    reutrn 0;
}
```

### ìŠ¤íƒ

```cpp
#include <stack>
int main(void){
    stack<int> s;
    s.push(1);
    s.push(2);
    s.pop();
    while(!s.empty()){
        cout<<s.top()<<' ';
        s.pop();
    }
    return 0;
}
```

- - - -
## í™ ì •ë ¬ O(n*logn)

* í™ì •ë ¬ì€ ë³‘í•©ì •ë ¬ê³¼ í€µì •ë ¬ë§Œí¼ ë¹ ë¥¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜.
* í™ íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ê¸°ì— í™ì— ëŒ€í•´ ë°°ìš¸ í•„ìš”ê°€ ìˆìŒ.
![](AlgorithmSummary/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-02-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.10.36.png)
- í™ì—ëŠ” ìµœëŒ€ í™ê³¼ ìµœì†Œ í™ì´ ì¡´ì¬í•¨. 
	- **ìµœëŒ€ í™**ì€ ë¶€ëª¨ ë…¸ë“œê°€ ìì‹ ë…¸ë“œë³´ë‹¤ í° í™.

í•˜ì§€ë§Œ ì´ëŸ¬í•œ í™ì´ ë¶•ê´´ë˜ëŠ” ê²½ìš°ê°€ ìˆëŠ”ë°, ì•„ë˜ì™€ ê°™ì€ ê²½ìš° ì´ˆë¡ìƒ‰ ë°•ìŠ¤ ë…¸ë“œëŠ” ìµœëŒ€ í™ì´ êµ¬ì„±ë˜ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤.
![](AlgorithmSummary/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-02-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.17.09.png)
í™ ì •ë ¬ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ì„œëŠ” í™ ìƒì„± ì•Œê³ ë¦¬ì¦˜(Heapify Algorithm)ì„ ì´ìš©í•œë‹¤. í™ ìƒì„± ì•Œê³ ë¦¬ì¦˜ì€ íŠ¹ì •í•œ â€˜í•˜ë‚˜ì˜ ë…¸ë“œâ€™ì— ëŒ€í•´ì„œ ìˆ˜í–‰í•˜ëŠ” ê²ƒ. 
ë˜í•œ í•´ë‹¹ â€˜í•˜ë‚˜ì˜ ë…¸ë“œë¥¼ ì œì™¸í•˜ê³ ëŠ” ìµœëŒ€ í™ì´ êµ¬ì„±ë˜ì–´ ìˆëŠ” ìƒíƒœâ€™ë¼ê³  ê°€ì •ì„ í•œë‹¤ëŠ” íŠ¹ì§•ì´ ìˆë‹¤.
	- **í™ ìƒì„± ì•Œê³ ë¦¬ì¦˜**:  ~íŠ¹ì • ë…¸ë“œì˜ ë‘ ìì‹ ì¤‘ì—ì„œ ë” í° ìì‹ê³¼ ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ë°”ê¾¸ëŠ” ì•Œê³ ë¦¬ì¦˜~
	ë˜í•œ ë°”ê¾¼ ë’¤ì—ë„ ì—¬ì „íˆ ìì‹ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ë˜ ìì‹ ì¤‘ì—ì„œ ë” í° ìì‹ê³¼ ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ë°”ê¿”ì•¼ í•œë‹¤.
	- ê³¼ì • : 5 / (7, 4) -> 7 / (5, 4)

- íˆí”¼íŒŒì´ë¥¼ ìƒí–¥ì‹/í•˜í–¥ì‹ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ.

**íˆí”¼íŒŒì´ë¡œ ì •ë ¬ì€ ì–´ë–»ê²Œ í•˜ë‚˜ìš”?**
ìµœìƒìœ„ ë¶€ëª¨ë…¸ë“œ(ë£¨íŠ¸ ë…¸ë“œ)ì—ëŠ” ë¬´ì¡°ê±´ í•´ë‹¹ íŠ¸ë¦¬ì—ì„œ ê°€ì¥ í° ê°’ì´ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì—, í•´ë‹¹ ê°’ì„ íŠ¸ë¦¬ì˜ ë§ˆì§€ë§‰ ì›ì†Œì™€ ìë¦¬ë¥¼ ë°”ê¾¼ë‹¤.
-> ì´ì–´ì„œ, ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ì œì™¸í•œ ë°°ì—´ì—ì„œ íˆí”¼íŒŒì´ë¥¼ í†µí•´ ë£¨íŠ¸ ë…¸ë“œì— ìµœëŒ“ê°’ì´ ì˜¤ê²Œ ë˜ê³ , í•´ë‹¹ ìµœëŒ“ê°’ì„ ì§‘í•©ì˜ ë§ˆì§€ë§‰ ì›ì†Œì™€ ìë¦¬ ë°”ê¾¼ë‹¤. (ì‚¬ì‹¤ì€ ë§ˆì§€ë§‰-1)
(ì¬ê·€â€¦ ë˜ ì¬ê·€â€¦)

`êµ¬í˜„`
```cpp
#include <stdio.h>

int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(void) {
    // í™ì„ êµ¬ì„±
    //ì ì  ì˜ì—­ì„ ë„“í˜€ê°€ë©° ìµœëŒ€ í™ì„ êµ¬í˜„í•¨. ìƒí–¥ì‹.
    for(int i = 1; i < number; i++) {
        int c = i;
        do {
            //ë°°ì—´ì—ì„œ ìì‹ë…¸ë“œë¡œ ë¶€ëª¨ë…¸ë“œ ì°¾ëŠ” ê³µì‹
            int root = (c - 1) / 2;
            //ìì‹ë…¸ë“œê°€ ë¶€ëª¨ë…¸ë“œë³´ë‹¤ ê°’ì´ í¬ë©´ êµì²´
            if(heap[root] < heap[c]) {
                int temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            c = root;  //ìœ„ìª½ê¹Œì§€ ë‹¤ ê²€ì‚¬í•˜ê¸° ìœ„í•´ì„œ í˜„ ë¶€ëª¨ë…¸ë“œë¥¼ ìì‹ìœ¼ë¡œ ì·¨í•˜ëŠ” ìƒˆ ë¶€ëª¨ë…¸ë“œì™€ ë˜ ê²€ì‚¬.
        } while (c != 0);
        //ë¶€ëª¨ë…¸ë“œê¹Œì§€ ìµœëŒ€ í™ì´ ë  ë•Œê¹Œì§€ ë°˜ë³µ. ë¶€ëª¨ë…¸ë“œê°€ ìµœëŒ“ê°’ì´ ë˜ë©´ ì¢…ë£Œ.
    }
    
    // í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©° ë°˜ë³µì ìœ¼ë¡œ í™ì„ êµ¬ì„±
    // iê°’ì´ ê°ì†Œí•˜ë©´ì„œ ë°°ì—´ ëì—ì„œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ í° ê°’ìœ¼ë¡œ ë°”ë€œ.
    for (int i = number - 1; i >= 0; i--) {
        //ë£¨íŠ¸ ë…¸ë“œ(ìµœìƒìœ„ ë…¸ë“œ)ê°€ ë¬´ì¡°ê±´ ìµœëŒ€ê°’ì´ë¯€ë¡œ ë§ˆì§€ë§‰ìœ¼ë¡œ ë°€ì–´ëƒ„.(ìë¦¬ êµí™˜)
        int temp = heap[0];
        heap[0] = heap[i];
        heap[i] = temp;
        int root = 0;
        int c = 1;
        //ì´ì œ ë‹¤ì‹œ ìµœëŒ€í™ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œ ëŒ€ì¥ì •...
        do {
            //ìì‹ ì°¾ëŠ” ê³µì‹~
            c = 2 * root + 1;
            // ìì‹ ì¤‘ì— ë” í° ê°’ì„ ì°¾ê¸°
            if(c < i - 1 && heap[c] < heap[c + 1]) {
                c++;
            }
            // ë£¨íŠ¸ë³´ë‹¤ ìì‹ì´ í¬ë‹¤ë©´ êµí™˜
            if(c < i && heap[root] < heap[c]) {
                temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            root = c;
        } while (c < i);
    }
    
    // ê²°ê³¼ ì¶œë ¥
    for(int i = 0; i < number; i++) {
        printf("%d ", heap[i]);
    }
}
```
- ìƒí–¥ì‹ : [ë™ë¹ˆë‚˜](https://youtu.be/iyl9bfp_8ag), [Zeddi](https://www.youtube.com/watch?v=aOP81IhPOmw)


- - - -
## ê³„ìˆ˜ ì •ë ¬(Counting Sort)
- ë°ì´í„°ê°€ a~b ì‚¬ì´ì— ì†í•œë‹¤ëŠ” íŠ¹ì§•ì´ ìˆì„ ë•Œ, â€˜ë²”ìœ„ ì¡°ê±´â€™ì´ ìˆëŠ” ê²½ìš°ì— í•œí•´ì„œ êµ‰ì¥íˆ ë¹ ë¥¸ O(n)ì˜ ì†ë„ë¥¼ ê°€ì§€ëŠ” ì•Œê³ ë¦¬ì¦˜.
- ë°©ë²•ì€? ë‹¨ìˆœíˆ í¬ê¸°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„¸ë©´ ë¨!

ex) 1, 3, 2, 4, 3, 5 ë°ì´í„°ë¥¼ ì •ë ¬í•´ë¼
	-> 1: 1ê°œ / 2: 1ê°œ / 3: 2ê°œ / 4: 1ê°œ / 5: 1ê°œ
ê²°ê³¼ : 1, 2, 3, 3, 4, 5
```cpp
#include <iostream>

int main(){
    int count[6]={0,};
    int array[30] = {
        1,3,2,4,3,2,5,3,1,2,
        3,4,4,3,5,1,2,3,5,2,
        3,1,4,3,5,1,2,1,1,1};
        
    for(int i=1;i<=5;i++){
        count[i]=0;
    }
    for(int i=0;i<30;i++){
        count[array[i]]++;
    }
    for(int i=1;i<6;i++){
        printf("%d: %dê°œ\n",i,count[i]);
        if(count[i]!=0){
            for(int j=0;j<count[i];j++){
                printf("%d\n", i);
            }
        }
        
    }
    return 0;
}
```

- - - -
## ì‹¬í™” ì •ë ¬ ë¬¸ì œ í’€ì´
- - - -
## ìŠ¤íƒ
```cpp
#include <iostream>
#include <stack>

using namespace std;

int main(void) {
	stack<int> s;
	s.push(7);
	s.push(5);
	s.push(4);
	s.pop();
	s.push(6);
	s.pop();
	while(!s.empty()) {
		cout << s.top() << â€˜ â€˜;
		s.pop();
	}
	return 0;
}
```
- - - -
## í
```cpp
#include <iostream>
#include <queue>

using namespace std;

int main(void) {
	queue<int> q;
	q.push(7);
	q.push(5);
	q.push(4);
	q.pop();
	q.push(6);
	q.pop();
	while(!q.empty()) {
		cout << q.front() << â€˜ â€˜;
		q.pop();
	}
	return 0;
}
```
- - - -
## ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS)
- ë„ˆë¹„ë¥¼ ìš°ì„ ìœ¼ë¡œ í•˜ì—¬ íƒìƒ‰ì„ ìˆ˜í–‰í•˜ëŠ” íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜.
- ë§¹ëª©ì ì¸ íƒìƒ‰ì„ í•˜ê³ ì í• ë•Œ ì‚¬ìš©.
- ~ìµœë‹¨ ê²½ë¡œ~ë¥¼ ì°¾ì•„ì¤€ë‹¤ëŠ” ì ì—ì„œ ìµœë‹¨ ê¸¸ì´ë¥¼ ë³´ì¥í•´ì•¼ í•  ë•Œ ë§ì´ ì‚¬ìš©!
- ~í~ë¥¼ ì´ìš©í•´ êµ¬í˜„.
```cpp
void bfs(int start){
    queue<int> q;
    q.push(start);
    c[start]=true;
    while(!q.empty()){
        int x = q.front();
        q.pop();
        printf("%d ", x);
        for(int i=0;i<a[x].size();i++){
            int y=a[x][i];
            if(!c[y]){
                q.push(y);
                c[y]=true;
            }
        }
    }
}
```

- - - -
## ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)
- ê¹Šì€ ê²ƒì„ ìš°ì„ ìœ¼ë¡œ í•˜ì—¬ íƒìƒ‰.
- ë§¹ëª©ì ìœ¼ë¡œ ê° ë…¸ë“œë¥¼ ì „ì²´ì ìœ¼ë¡œ íƒìƒ‰í•  ë•Œ 
```cpp
void dfs(int x){
    if(c[x]) return;
    c[x]=true;
    cout<<x<<' ';
    for(int i=0;i<a[x].size();i++){
        int y = a[x][i];
        dfs(y);
    }
}
```

- - - -
## í•©ì§‘í•© ì°¾ê¸°(Union-Find)
- ëŒ€í‘œì ì¸ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜.
- ì„œë¡œì†Œ ì§‘í•©(Disjoint-Set) ì•Œê³ ë¦¬ì¦˜ì´ë¼ê³ ë„ ë¶ˆë¦¼.
- ì—¬ëŸ¬ ê°œì˜ ë…¸ë“œê°€ ì¡´ì¬í•  ë•Œ, ë‘ ê°œì˜ ë…¸ë“œë¥¼ ì„ íƒí•´ì„œ í˜„ì¬ ì´ ë‘ ë…¸ë“œê°€ ì„œë¡œ ê°™ì€ ê·¸ë˜í”„ì— ì†í•˜ëŠ”ì§€ë¥¼ íŒë³„í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.
- (3)-(2)-(1)ë¡œ ì—°ê²°ë˜ì–´ìˆì„ ë•Œ, ë…¸ë“œ 3ê³¼ ë…¸ë“œ 1ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€(ê°™ì€ ê·¸ë˜í”„ì— ì†í•´ìˆëŠ”ì§€) ì•Œì•„ë³´ë ¤ë©´ 3ì˜ ë¶€ëª¨ë¥¼ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•˜ë©´ì„œ 1ì´ ìˆëŠ”ì§€ ì°¾ì•„ë³´ì•„ì•¼ í•¨. (Union-Find)

``` cpp
#include <stdio.h>
//ë¶€ëª¨ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜
int getParent(int parent[], int x){
    if(parent[x]==x) return x;
    return parent[x]=getParent(parent,parent[x]);
}
//ë‘ ë¶€ëª¨ ë…¸ë“œë¥¼ í•©ì¹˜ëŠ” í•¨ìˆ˜. (ì‘ì€ ê°’ìœ¼ë¡œ ë¶€ëª¨ í•©ì¹¨.)
void unionParent(int parent[], int a, int b){
    a=getParent(parent,a);
    b=getParent(parent,b);
    if(a<b) parent[b]=a;
    else parent[a]=b;
}
//ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì§€ëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
int findParent(int parent[], int a, int b){
    a=getParent(parent,a);
    b=getParent(parent,b);
    if(a==b) return 1;
    return 0;
}
int main(void){
    int parent[11];
    for(int i=1;i<=10;i++){
        parent[i]=i;
    }
    unionParent(parent,1,2);
    unionParent(parent,2,3);
    unionParent(parent,3,4);
    unionParent(parent,5,6);
    unionParent(parent,6,7);
    unionParent(parent,7,8);
    
    printf("1ê³¼ 5ëŠ” ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”? %d\n",findParent(parent,1,5));
    unionParent(parent,1,5);
    printf("1ê³¼ 5ëŠ” ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”? %d\n",findParent(parent,1,5));
    
    printf("7ê³¼ 9ëŠ” ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”? %d\n",findParent(parent,7,9));
    unionParent(parent,8,9);
    printf("7ê³¼ 9ëŠ” ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”? %d\n",findParent(parent,7,9));
}
```

- - - -
## í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal Algorithm)
[ì•ˆê²½ì¡ì´ê°œë°œì : ë„¤ì´ë²„ ë¸”ë¡œê·¸](https://blog.naver.com/ndb796/221230994142)
- ê°€ì¥ ì ì€ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.
(ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ëŒ€í‘œì  ì•Œê³ ë¦¬ì¦˜)

- **ìš©ì–´ ì •ë¦¬**
	- ë…¸ë“œ=ì •ì =ë„ì‹œ : ê·¸ë˜í”„ì—ì„œ ë™ê·¸ë¼ë¯¸
	- ê°„ì„ =ê±°ë¦¬=ë¹„ìš© : ê·¸ë˜í”„ì—ì„œ ì„ 
- ê°„ì„  ìˆ«ì = ë…¸ë“œ ìˆ«ì -1
-> ì£¼ì˜í•  ì  : ì‹¸ì´í´ì´ í˜•ì„±ë˜ì§€ ì•Šë„ë¡ ì¡°ì‹¬í•˜ê¸°!

**<ì•Œê³ ë¦¬ì¦˜>**
1. (ë¹„ìš© ë‚®ì€ ìˆœìœ¼ë¡œ) ì •ë ¬ëœ ìˆœì„œì— ë§ê²Œ ê·¸ë˜í”„ì— í¬í•¨
2. í¬í•¨ì‹œí‚¤ê¸° ì „ì—ëŠ” ì‚¬ì´í´ í…Œì´ë¸”ì„ í™•ì¸
3. ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ê²½ìš°ì—ëŠ” ê°„ì„ ì„ í¬í•¨í•˜ì§€ ì•ŠìŒ.
(ì‚¬ì´í´ì€ Union-Findì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•´ì„œ ì°¾ê¸°!)

```cpp
#include <vector>
// ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ì ¸ì˜´
int getParent(int set[], int x) {
    if(set[x] == x) return x;
    return set[x] = getParent(set, set[x]);
}
// ë¶€ëª¨ ë…¸ë“œë¥¼ ë³‘í•©
void unionParent(int set[], int a, int b) {
    a = getParent(set, a);
    b = getParent(set, b);
    // ë” ìˆ«ìê°€ ì‘ì€ ë¶€ëª¨ë¡œ ë³‘í•©
    if(a < b) set[b] = a;
    else set[a] = b;
}
// ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì§€ëŠ”ì§€ í™•ì¸
int find(int set[], int a, int b) {
    a = getParent(set, a);
    b = getParent(set, b);
    if(a == b) return 1;
    else return 0;
}
// ê°„ì„  í´ë˜ìŠ¤ ì„ ì–¸
class Edge {
public:
    int node[2];
    int distance;
    Edge(int a, int b, int distance) {
        this->node[0] = a;
        this->node[1] = b;
        this->distance = distance;
    }
    bool operator <(const Edge &edge) const {
        return this->distance < edge.distance;
    }
};

int main(void) {
    const int n = 7;
    
    vector<Edge> v;
    v.push_back(Edge(1, 7, 12));
    v.push_back(Edge(1, 4, 28));
    v.push_back(Edge(1, 2, 67));
    v.push_back(Edge(1, 5, 17));
    v.push_back(Edge(2, 4, 24));
    v.push_back(Edge(2, 5, 62));
    v.push_back(Edge(3, 5, 20));
    v.push_back(Edge(3, 6, 37));
    v.push_back(Edge(4, 7, 13));
    v.push_back(Edge(5, 6, 45));
    v.push_back(Edge(5, 7, 73));
    
    // ê°„ì„ ì˜ ë¹„ìš©ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    sort(v.begin(), v.end());
    
    // ê° ì •ì ì´ í¬í•¨ëœ ê·¸ë˜í”„ê°€ ì–´ë””ì¸ì§€ ì €ì¥
    int set[n];
    for(int i = 0; i < n; i++) {
        set[i] = i;
    }
    
    // ê±°ë¦¬ì˜ í•©ì„ 0ìœ¼ë¡œ ì´ˆê¸°í™”
    int sum = 0;
    for(int i = 0; i < v.size(); i++) {
        // ë™ì¼í•œ ë¶€ëª¨ë¥¼ ê°€ë¥´í‚¤ì§€ ì•ŠëŠ” ê²½ìš°, ì¦‰ ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•Šì„ ë•Œë§Œ ì„ íƒ
        if(!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) {
            sum += v[i].distance;
            unionParent(set, v[i].node[0] - 1, v[i].node[1] - 1);
        }
    }
    
    printf("%d\n", sum);
}
```

## ğŸ¤” ì ê¹, `bool operator < (ë¨¸ì‹œêºµì´..`ëŠ” ë­ì˜€ì§€~? ì—°ì‚°ì ì˜¤ë²„ë¡œë”©!!

- ìœ„ì˜ ì˜ˆì œì™€ ê°™ì€ Edge í´ë˜ìŠ¤ê°€ ìˆë‹¤ê³  ì¹˜ì. (ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì´ ì—†ë‹¤ë©´)
``` cpp
Edge Edge1=Edge(1,7,12);
Edge Edge2=Edge(1,4,28(;
cout << Edge1 + Edge2 << endl;
```
í•˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤!

-> Edge í´ë˜ìŠ¤ì— ì´ëŸ¬í•œ ì—°ì‚°ì ì˜¤ë²„ë¡œë”© ë©”ì†Œë“œë¥¼ ì¶”ê°€í•˜ë©´ í•´ê²°ëœë‹¤!
```cpp
int operator+(Edge &edge){
	return this->distance + edge.distance;
}
```
- ì¶”ê°€í•´ì£¼ë©´ `e1+e2`ëŠ” `e1.operator+(e2)`ì™€ ê°™ì€ ì˜ë¯¸ë¥¼ ì§€ë‹Œë‹¤.
- ìì„¸íˆ ì„¤ëª…í•˜ìë©´, ~e1 ê°ì²´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë©”ì†Œë“œ operator+ë¥¼ í˜¸ì¶œí•˜ê³ , ë§¤ê°œë³€ìˆ˜ë¡œ e2ë¥¼ ë°›ëŠ”ë‹¤.~

- ë‹¨, ì£¼ì˜í•  ì ì€ algorithm í—¤ë”ì—ì„œ ì˜¤ë¥˜ê°€ ë‚  ë•Œê°€ ìˆëŠ”ë°, ë°©ì§€í•˜ê¸° ìœ„í•´ì„œ ë§¤ê°œë³€ìˆ˜ë“¤ì„ ëª¨ë‘ `const`ë¡œ ë°›ìœ¼ë©´ ëœë‹¤.
( `const` ë¥¼ ëª…ì‹œí•˜ê²Œ ë˜ë©´ operator ë©”ì†Œë“œ ì•ˆì—ì„œëŠ” ì–´ë–¤ ë³€ìˆ˜ë„ ë°”ê¿€ ìˆ˜ ì—†ê³ , constê°€ ì•„ë‹Œ ë©”ì†Œë“œë¥¼ ë¶€ë¥¼ ìˆ˜ë„ ì—†ê²Œ ëœë‹¤.)
[C++ ì—°ì‚°ì ì˜¤ë²„ë¡œë”©(Overloading)](https://ssungkang.tistory.com/entry/C-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9Overloading)

- - - -
## ì´ì§„íŠ¸ë¦¬ì˜ êµ¬í˜„ê³¼ ìˆœíšŒ(Traversal) ë°©ì‹
- ì´ì§„íŠ¸ë¦¬ë¥¼ êµ¬í˜„í•  ë•ŒëŠ” ë°ì´í„°ì˜ ë‚­ë¹„(ë¹ˆ ë°°ì—´ë¡œ ìë¦¬ë§Œ ì°¨ì§€í•˜ëŠ” ê²ƒ)ë¥¼ ì¤„ì´ê¸° ìœ„í•´ì„œ í¬ì¸í„°ë¡œ êµ¬í˜„í•œë‹¤.

**ì„¸ ê°€ì§€ ìˆœíšŒ ë°©ë²•**
1. ì „ìœ„ ìˆœíšŒ(Preorder Traversal)
1) ë¨¼ì € ìê¸° ìì‹ ì„ ì²˜ë¦¬
2) ì™¼ ìì‹ ë°©ë¬¸
3) ì˜¤ë¥¸ ìì‹ ë°©ë¬¸
2. ì¤‘ìœ„ ìˆœíšŒ(Inorder Traversal)
1) ì™¼ ìì‹ ë°©ë¬¸
2) ìê¸° ìì‹  ì²˜ë¦¬
3) ì˜¤ë¥¸ ìì‹ ë°©ë¬¸
3. í›„ìœ„ ìˆœíšŒ(Postorder Traversal) 
1) ì™¼ ìì‹ ë°©ë¬¸
2) ì˜¤ë¥¸ ìì‹ ë°©ë¬¸
3) ìê¸° ìì‹  ì²˜ë¦¬
-> ì»´í“¨í„°ì—ì„œ ìˆ˜ì‹ ì²˜ë¦¬í•  ë•ŒëŠ” í›„ìœ„ìˆœíšŒë¥¼ ì£¼ë¡œ ì‚¬ìš©í•¨.


```cpp
int number = 15;

typedef struct node *treePointer;
typedef struct node {
    int data;
    treePointer leftChild, rightChild;
} node;
//Preorder traversal
void preorder(treePointer ptr){
    if(ptr){
        cout << ptr->data << ' ';
        preorder(ptr->leftChild);
        preorder(ptr->rightChild);
    }
}
//Inorder traversal
void inorder(treePointer ptr){
    if(ptr){
        inorder(ptr->leftChild);
        cout << ptr->data << ' ';
        inorder(ptr->rightChild);
    }
}
//Postorder traversal
void postorder(treePointer ptr){
    if(ptr){
        postorder(ptr->leftChild);
        postorder(ptr->rightChild);
        cout << ptr->data << ' ';
    }
}
int main(void) {
    node nodes[number+1];
    for(int i=1;i<=number;i++){
        nodes[i].data = i;
        nodes[i].leftChild = NULL;
        nodes[i].rightChild = NULL;
    }
    for(int i=1;i<=number;i++){
        if(i%2==0)
            nodes[i/2].leftChild = &nodes[i];
        else
            nodes[i/2].rightChild = &nodes[i];
    }
    cout << "ì „ìœ„ : ";
    preorder(&nodes[1]);
    cout << '\n';
    
    cout << "ì¤‘ìœ„ : ";
    inorder(&nodes[1]);
    cout << '\n';
    
    cout << "í›„ìœ„ : ";
    postorder(&nodes[1]);
    cout << '\n';
    return 0;
}
```

- - - -
## ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°(Dynamic Programming)ì˜ ì›ë¦¬
- ëŒ€íšŒì— ì§„~~~ì§œ ë§ì´ ë‚˜ì˜¤ëŠ” ê°œë…! í”¼í•  ìˆ˜ ì—†ëŠ” ìˆ™ëª…!
- ë¬¸ì œ ì¢…ë¥˜ê°€ ë§ê³ , ì»´í“¨í„°ì ì¸ ì‚¬ê³ ë ¥ì„ ë¬¼ì–´ë³´ê¸°ì— ì í•©í•¨.
- ì¤„ì—¬ì„œ  DP, ë™ì ê³„íšë²• ì´ë¼ê³ ë„ í•¨. 
- **í•˜ë‚˜ì˜ ë¬¸ì œë¥¼ ~ë‹¨ í•œ ë²ˆ~ë§Œ í’€ë„ë¡ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.**
::but::
- ~ë¶„í•  ì •ë³µ ê¸°ë²•ì€ ëª‡ëª‡ ìš”ì†Œì—ì„œ ë™ì¼í•œ ë¬¸ì œë¥¼ ë‹¤ì‹œ í‘¼ë‹¤~ ëŠ” ë‹¨ì ì„ ê°€ì§„ë‹¤.
(ì˜ˆë¥¼ ë“¤ì–´, ì¬ê·€ì ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ë™ì¼í•œ ë°ì´í„°ë¥¼ ë°˜ë³µí•´ì„œ ë¬¼ì–´ë´ì•¼í•¨. í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ ê°™ì€ ì í™”ì‹ì„ ì´ìš©í•˜ëŠ” ë¬¸ì œê°€ ëŒ€í‘œì ì¸ ì˜ˆì‹œ)
- ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì€ ë‹¤ìŒì˜ ê°€ì • í•˜ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
	1. ë²ˆ ê°€ì •) í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.
	2. ë²ˆ ê°€ì •) ì‘ì€ ë¬¸ì œì—ì„œ êµ¬í•œ ì •ë‹µì€ ê·¸ê²ƒì„ í¬í•¨í•˜ëŠ” í° ë¬¸ì œì—ì„œë„ ë™ì¼í•˜ë‹¤.â˜…
- í¬ê³  ì–´ë ¤ìš´ ë¬¸ì œê°€ ìˆì„ ë•Œ ê·¸ê²ƒì„ ë¨¼ì € ì˜ê²Œ ë‚˜ëˆ„ì–´ì„œ í•´ê²°í•œ ë’¤ì— ì²˜ë¦¬í•˜ì—¬ ë‚˜ì¤‘ì— ì „ì²´ì˜ ë‹µì„ êµ¬í•˜ê¸° ìœ„í•´ ë©”ëª¨ì´ì œì´ì…˜(Memoization)ì´ ì‚¬ìš©ëœë‹¤.
- - - -
### í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ ì˜ˆì‹œ
```c
int dp(int x){
    if(x==1) return 1;
    if(x==2) return 1;
    return dp(x-1) + dp(x-2);
}
int main(void) {
    printf("%d",dp(10));
    return 0;
}
```
ğŸ‘‰ í•˜ì§€ë§Œ, ì´ëŸ° ë°©ì‹ìœ¼ë¡œ 50ë²ˆì§¸ í•­ì„ êµ¬í•œë‹¤ê³  ì¹˜ë©´ ì—„~ì²­ ì˜¤ë˜ ê±¸ë¦¼.
(në²ˆì§¸ë¥¼ ê³„ì‚°í•˜ë ¤ë©´ 2^në²ˆ ê³„ì‚°ì„ í•´ì•¼í•¨. ì–µê²ì˜ ì‹œê°„ì´ ê±¸ë¦°ë‹¤.)

### ë©”ëª¨ì´ì œì´ì…˜ ì˜ˆì‹œ
: ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° ê¸°ë²•ì„ ì´ìš©í•˜ì—¬ ê°œì„ ì‹œì¼°ë‹¤!
```cpp
int dp(int x){
    if(x==1) return 1;
    if(x==2) return 1;
    if(d[x]!=0) return d[x];
    return d[x] = dp(x-1)+dp(x-2);
}
```
ì¬ê·€í•¨ìˆ˜ì ì¸ ì‚¬ê³ ë ¥ì„ ìš”êµ¬í•˜ê¸° ë•Œë¬¸ì— ì•„ì£¼~ ì¤‘ìš”í•œ ë¶€ë¶„ì´ë‹¤.

- - - -
## ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° íƒ€ì¼ë§ ë¬¸ì œ í’€ì–´ë³´ê¸°
- ê¸°ë³¸ì ì¸ ë¬¸ì œë¡œ ëŒ€í‘œì ì¸ê²Œ íƒ€ì¼ë§ ë¬¸ì œ. ì í™”ì‹ì„ ì„¸ì›Œë³´ì.
### 11726 íƒ€ì¼ ì±„ìš°ê¸°
[11726ë²ˆ](https://www.acmicpc.net/problem/11726)
![](AlgorithmSummary/29771259-C595-41BE-AB2F-C8A441083976.png)
- D[N] : 2xN ì‚¬ì´ì¦ˆì˜ ì§ì‚¬ê°í˜•ì„ 1x2, 2x1 ì‚¬ê°í˜•ìœ¼ë¡œ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜
- D[0] = D[1] = 1
- D[N-1] : ë§ˆì§€ë§‰ ì¡°ê°ì„ 2x1 ì‚¬ê°í˜•ìœ¼ë¡œ ì±„ìš´ ë°©ë²•ì˜ ìˆ˜
- D[N-2] : ë§ˆì§€ë§‰ ì¡°ê°ì„ 1x2 ì‚¬ê°í˜• 2ê°œë¡œ ì±„ìš´ ë°©ë²•ì˜ ìˆ˜
![](AlgorithmSummary/3FA434DE-A5CF-49CF-AC6B-5AFE533849D5.png)

~ê·¸ëŸ¼, ëì— 3ì´ ë‚¨ëŠ” ê²½ìš°ì—ëŠ”?~
-> 1x2ë¡œ 2ê°œë¡œ ì±„ìš°ê³  ê¸¸ì´ê°€ 1ì´ ë‚¨ëŠ” ê²½ìš° => N-1ê°œì˜ íƒ€ì¼ì„ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜
-> 2x1ë¡œ ì±„ìš°ê³  ê¸¸ì´ê°€ 2ê°€ ë‚¨ëŠ” ê²½ìš° => N-2ê°œì˜ íƒ€ì¼ì„ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜
ì´ë ‡ê²Œ 2ê°€ì§€ ë°©ì‹ìœ¼ë¡œë§Œ ëë‚œë‹¤.
âˆ´ Nê°œì˜ íƒ€ì¼ì„ ì±„ìš°ëŠ” ë°©ì‹ì€ N-1ê°œì˜ íƒ€ì¼ì„ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜ì™€ N-2ê°œì˜ íƒ€ì¼ì„ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜ì˜ í•©ì´ ëœë‹¤.

### 11727 íƒ€ì¼ ì±„ìš°ê¸°2
![](AlgorithmSummary/4A947F3F-6493-42CB-8FCA-D247D820FC35.png)
- D[N] : 2xN ì‚¬ì´ì¦ˆì˜ ì§ì‚¬ê°í˜•ì„ 1x2, 2x1, 2x2 ì‚¬ê°í˜•ìœ¼ë¡œ ì±„ìš°ëŠ” ë°©ë²•ì˜ ìˆ˜
- D[0] = D[1] = 1
- D[N-1] : ë§ˆì§€ë§‰ ì¡°ê°ì„ 2x1 ì‚¬ê°í˜•ìœ¼ë¡œ ì±„ìš´ ë°©ë²•ì˜ ìˆ˜
- D[N-2] : ë§ˆì§€ë§‰ ì¡°ê°ì„ 1x2 ì‚¬ê°í˜• 2ê°œ ë˜ëŠ” 2x2 ì‚¬ê°í˜•ìœ¼ë¡œ ì±„ìš´ ë°©ë²•ì˜ ìˆ˜
![](AlgorithmSummary/70C154A1-A680-4445-B82B-00CB13E73AE3.png)

### 2133 íƒ€ì¼ë§ ë†’ì´ 3
![](AlgorithmSummary/75CFEB2F-A2D8-4CB7-B326-CA7BE065E769.png)
```cpp
int dp(int x){
    if(x==0) return 1;
    if(x==1) return 0;
    if(x==2) return 3;
    if(d[x]!=0) return d[x];
    int result=3*dp(x-2);
    for(int i=3;i<=x;i++){
        if(i%2==0)
            result+=2*dp(x-i);
    }
    return d[x]=result;
}
```

### 14852 íƒ€ì¼ ì±„ìš°ê¸°3

![](AlgorithmSummary/5C170DA5-45F0-4A10-886F-6307AF32C1E2.png)

```cpp
int d[1000001],n;
int dp(int x){
    if(x==0) return 1;
    if(x==1) return 2;
    if(x==2) return 7;
    if(d[x]!=0) return d[x];
    int result=3*dp(x-2)+2*dp(x-1);
    for(int i=3;i<=x;i++){
        result+=(2*dp(x-i))%1000000007;
    }
    return d[x]=result%1000000007;
}
```
âš ï¸ì‹œê°„ì´ˆê³¼ ë‘ë‘¥!!
ì–´ë–»ê²Œ í•˜ë©´ íš¨ìœ¨ì ìœ¼ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜ì •í•  ìˆ˜ ìˆì„ê¹Œ? -> **2ì°¨ì› DP**!!

![](AlgorithmSummary/F008D97D-250E-49DA-A1B6-3FB27276B5B7.png)
[2. Dynamic Programming (DP)](https://norman3.github.io/rl/docs/chapter02.html)

- - - -
### ì ê¹, ì¬ê·€í•¨ìˆ˜ì— ëŒ€í•´ ì•Œì•„ë³´ì!
```java
function recursive (ì¸ì) {
	ì‘ì—… ìˆ˜í–‰
	if (ì¡°ê±´ì¶©ì¡±) {
		return ê²°ê³¼
	} else {
		return recursive (ì‘ì—…ëœ ì¸ì)
	}
}
```
- ê·¼ë°, ì¬ê·€í•¨ìˆ˜ë¡œ ì§œì¸ ì½”ë“œë“¤ì€ ë°˜ë³µë¬¸ìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥í•˜ê³ , ê·¸ë ‡ê²Œ ì ëŠ”ê²Œ ë” ì‰¬ìš´ ê²½ìš°ë„ ë§ë‹¤.
- í•˜ì§€ë§Œ ì˜ˆë¥¼ ë“¤ì–´ {1, 2, [2, 4, [4, 3]], 5} ì˜ í•©ì„ êµ¬í•˜ëŠ” ê²½ìš°ì—ëŠ” 3ì¤‘ ë°˜ë³µë¬¸ì„ ì´ìš©í•´ì•¼í•˜ëŠ”ë°â€¦ -> ì´ëŸ´ ë•Œ ì¬ê·€í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì¢‹ë‹¤!
- ì¬ê·€ ì¢…íŠ¹ìœ¼ë¡œ ë°˜ë³µë¬¸ì— ë¹„í•´ ë©”ëª¨ë¦¬ë¥¼ ë§ì´ ì¡ì•„ë¨¹ëŠ”ë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤. (ìŠ¤íƒì— ê³„ì† ìŒ“ì—¬ì„œ)
- ğŸ”ºBUTğŸ”º ê¼¬ë¦¬ ì¬ê·€ ìµœì í™”ë¥¼ ì´ìš©í•˜ë©´ ë©”ëª¨ë¦¬ê°€ ë¹„ì›Œì§€ë¯€ë¡œ ê´œì°®ìŒ!
